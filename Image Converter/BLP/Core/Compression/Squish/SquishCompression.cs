// TODO: Break this out into a real library
// <auto-generated>
// ReSharper disable All
#pragma warning disable

// Note: this file is not actually auto-generated, but rather a straight source import from an external library.

using System;
using System.IO;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;

namespace Warcraft.Core.Compression.Squish
{
    public static class SquishCompression
    {
        public static int GetStorageRequirements(int width, int height, SquishOptions flags)
        {
            var blockCount = ((width + 3) / 4) * ((height + 3) / 4);
            var blockSize = flags.HasFlag(SquishOptions.DXT1) ? 8 : 16;
            return blockCount * blockSize;
        }

        #region On buffer

        public static byte[] CompressBlock(byte[] rgba, SquishOptions flags)
        {
            return CompressBlockMasked(rgba, 0xFFFF, flags);
        }

        public static byte[] CompressBlockMasked(byte[] rgba, int mask, SquishOptions flags)
        {
            flags = flags.FixFlags();

            var colours = new ColourSet(rgba, mask, flags);

            if (colours.Count == 1)
            {
                // Always do a single colour fit
                //SingleColourFit fit = new SingleColourFit(ref colours, flags);
            }
            else if (flags.HasFlag(SquishOptions.ColourRangeFit) || colours.Count == 0)
            {
                // Do a range fit
                //RangeFit fit = new RangeFit(ref colours, flags, metric);

            }
            else
            {
                // Default to a cluster fit (could be iterative or not)
                //ClusterFit fit = new ClusterFit(ref colours, flags, metric);
            }

            // Compress alpha separately if needed
            if (flags.HasFlag(SquishOptions.DXT3))
            {
                //Alpha.CompressAlphaDxt3(rgba, mask, alphaBlock);
            }
            else if (flags.HasFlag(SquishOptions.DXT5))
            {
                //Alpha.CompressAlphaDxt5(rgba, mask, alphaBlock);
            }

            throw new NotImplementedException();
        }

        public static byte[] DecompressBlock(byte[] block, int blockOffset, SquishOptions flags)
        {
            // Get the block locations
            var colOff = blockOffset;
            var alphaOff = blockOffset;
            if ((flags & (SquishOptions.DXT3 | SquishOptions.DXT5)) != 0)
            {
                colOff += 8;
            }

            // Decompress colour.
            var rgba = ColourBlock.DecompressColour(block, colOff, flags.HasFlag(SquishOptions.DXT1));

            // Decompress alpha seperately if necessary.
            if (flags.HasFlag(SquishOptions.DXT3))
            {
                Alpha.DecompressAlphaDxt3(block, alphaOff, rgba, 0);
            }
            else if (flags.HasFlag(SquishOptions.DXT5))
            {
                Alpha.DecompressAlphaDxt5(block, alphaOff, rgba, 0);
            }

            return rgba;
        }

        public static byte[] CompressImage(byte[] rgba, int width, int height, SquishOptions flags)
        {
            throw new NotImplementedException();
        }

        public static byte[] DecompressImage(byte[] blocks, int width, int height, SquishOptions flags)
        {
            return DecompressImage(blocks, 0, width, height, flags);
        }

        public static byte[] DecompressImage(byte[] blocks, int offset, int width, int height, SquishOptions flags)
        {
            var argb = new byte[4 * width * height];
            var bytesPerBlock = flags.HasFlag(SquishOptions.DXT1) ? 8 : 16;

            var blockOffset = offset;
            // Loop over blocks.
            for (var y = 0; y < height; y += 4)
            {
                for (var x = 0; x < width; x += 4)
                {
                    // Decompress the block.
                    var targetRgba = DecompressBlock(blocks, blockOffset, flags);

                    // Write the decompressed pixels to the correct image locations.
                    var sourcePixelOffset = 0;
                    for (var py = 0; py < 4; ++py)
                    {
                        for (var px = 0; px < 4; ++px)
                        {
                            // Get the target location.
                            var sx = x + px;
                            var sy = y + py;
                            if (sx < width && sy < height)
                            {
                                var targetPixelOffset = 4 * ((width * sy) + sx);
                                // Copy the rgba value
                                argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];
                                argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];
                                argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];
                                argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];
                            }
                            sourcePixelOffset += 4;
                        }
                    }

                    // advance
                    blockOffset += bytesPerBlock;
                }
            }
            return argb;
        }

        public static Image<Rgba32> DecompressToImage(byte[] blocks, int width, int height, SquishOptions flags)
        {
            return DecompressToImage(blocks, 0, width, height, flags);
        }

        public static Image<Rgba32> DecompressToImage(byte[] blocks, int offset, int width, int height, SquishOptions flags)
        {
            var result = new Image<Rgba32>(width, height);
            var bufferOffset = 0;

            var bytesPerBlock = flags.HasFlag(SquishOptions.DXT1) ? 8 : 16;
            var blockOffset = offset;
            // Loop over blocks.
            for (var y = 0; y < height; y += 4)
            {
                for (var x = 0; x < width; x += 4)
                {
                    // Decompress the block.
                    var targetRgba = DecompressBlock(blocks, blockOffset, flags);

                    // Write the decompressed pixels to the correct image locations.
                    var sourcePixelOffset = 0;
                    for (var py = 0; py < 4; ++py)
                    {
                        for (var px = 0; px < 4; ++px)
                        {
                            // Get the target location.
                            var sx = x + px;
                            var sy = y + py;
                            if (sx < width && sy < height)
                            {
                                var sourceColour = new Rgba32
                                (
                                    targetRgba[sourcePixelOffset + 0],
                                    targetRgba[sourcePixelOffset + 1],
                                    targetRgba[sourcePixelOffset + 2],
                                    targetRgba[sourcePixelOffset + 3]
                                );

                                result[sx, sy] = sourceColour;

                                /*
                                var i = 4 * (sx + (sy * width));
                                fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];
                                fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];
                                fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];
                                fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];
                                */
                            }

                            sourcePixelOffset += 4; // Skip this pixel as it is outside the image.
                        }
                    }

                    // advance
                    blockOffset += bytesPerBlock;
                }
            }

            return result;
        }

        #endregion

        #region On stream

        public static void CompressBlock(Stream input, Stream output, SquishOptions flags)
        {
            CompressBlockMasked(input, output, 0xFFFF, flags);
        }

        public static void CompressBlockMasked(Stream input, Stream output, int mask, SquishOptions flags)
        {
            throw new NotImplementedException();
        }

        public static void DecompressBlock(Stream input, Stream output, SquishOptions flags)
        {
            throw new NotImplementedException();
        }

        public static void CompressImage(Stream input, Stream output, int width, int height, SquishOptions flags)
        {
            throw new NotImplementedException();
        }

        public static void DecompressImage(Stream input, Stream output, int width, int height, SquishOptions flags)
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}
